---
layout: post
title: "7. 注册中心选型"
date: 1997-07-01
categories: Microservices
tags: microservice
excerpt: 注册中心选型
mathjax: true
---

- [1 注册中心如何存储服务](#1-注册中心如何存储服务)
- [2 注册中心具体工作流程](#2-注册中心具体工作流程)
  - [2.1 服务提供者注册](#21-服务提供者注册)
  - [2.2 提供者如何反注册](#22-提供者如何反注册)
  - [2.3 消费者查询节点信息](#23-消费者查询节点信息)
  - [2.4 消费者订阅服务变更](#24-消费者订阅服务变更)
- [3 注册与发现的几个问题](#3-注册与发现的几个问题)
- [4 服务注册中心选型](#4-服务注册中心选型)
  - [4.1 应用内：Eureka](#41-应用内eureka)
  - [4.2 应用外：Consul](#42-应用外consul)
  - [4.3 如何选择](#43-如何选择)
- [5 注册中心选型涉及的CAP理论](#5-注册中心选型涉及的cap理论)

### 1 注册中心如何存储服务

一般来说，我们的服务信息发布出去一般包含这些信息：

1. 节点信息
2. 服务名称
3. IP地址
4. 端口
5. 服务接口地址
6. 超时时间
7. 最大重试次数
8. 请求结果是否压缩

所以，一般我们的注册中心会提供一个层级关系的数据模型以供我们去描述发布出去的服务。通常来说，服务一般被划分为不同的多个分组，一般来说服务分组有三个层面：

1. 是否业务核心
2. 机房维度
3. 环境维度（线上、测试环境）

另外，注册中心存储的服务信息一般包含三个部分内容：分组、服务名、节点信息（包含节点地址、其他信息），数据一般按照`JSON`格式进行存储。

### 2 注册中心具体工作流程

> 注册中心具体工作主要包含服务提供者注册、反注册；服务消费者查询节点信息、订阅服务变更

#### 2.1 服务提供者注册

1. 检查是否在白名单内，即是否允许注册
2. 要注册的Cluster是否存在，不存在则抛出异常
3. 查看Service的分组是否存在，不存在则抛异常
4. 存入相应的store中

#### 2.2 提供者如何反注册

1. 查看Service分组是否存在
2. 查看Cluster是否存在
3. 删除Service和Cluster下对应的节点信息
4. 更新Cluster的sign值

#### 2.3 消费者查询节点信息

1. 从本地缓存中查找
2. 缓存不存在则从本地快照查找

#### 2.4 消费者订阅服务变更

1. 检查sign值是否一致
2. 不一致则更新本地缓存、更新本地快照
3. 一致则不做任何操作

### 3 注册与发现的几个问题

1. 多注册中心的支持
2. 并行订阅服务
3. 批量反注册
4. 服务信息增量更新

### 4 服务注册中心选型

对于注册中心的选型，当下主流的无非两种：

1. 应用内，通过注册中心配套的SDK，通过SDK与注册中心的交互从而实现服务的发现与注册
2. 应用外，不需要SDK，而是通过其他方式间接实现服务注册与发现

#### 4.1 应用内：Eureka

典型的应用内的服务注册中心就是Eureka，主要由三个组件构成，如下图：

![eureka](../../images/microservice/eureka_architecture.png)

1. Eureka Server：注册中心的服务端，实现了服务的注册、存储和查询功能
2. 服务端的Eureka Client：集成在服务端的注册中心SDK，服务提供者通过调用SDK，实现服务注册、反注册等功能
3. 客户端的Eureka Client：集成客户端的注册中心SDK，服务消费者通过调用SDK，实现服务订阅、服务更新等功能

#### 4.2 应用外：Consul

应用外的服务注册中心目前社区反馈较好的就是Consul，下面是它的架构图：

![consul_02](../../images/microservice/consul_02.png)

1. Consul：注册中心的服务端，实现服务注册信息的存储，并提供注册和发现服务
2. Registrator：一个开源的第三方服务管理器项目，它通过监听服务部署的 Docker 实例是否存活，来负责服务提供者的注册和销毁
3. Consul Template：定时从注册中心服务端获取最新的服务提供者节点列表并刷新 LB 配置（比如 Nginx 的 upstream），这样服务消费者就通过访问 Nginx 就可以获取最新的服务提供者信息

#### 4.3 如何选择

这两种服务注册中心的选择方案不同之处在于其应用的场景不同，区别如下：

1. `应用内的解决方案适用于解决同一个技术体系的服务`
2. `应用外的解决方案适用于不同技术体系的业务，如跨语言、平台`

另一方面，对于容器化大行其道的云生产应用而言，SDK的方式不太适合，因为这样会入侵代码，而应用外的解决方案正好能够解决这个问题。

### 5 注册中心选型涉及的CAP理论

为什么这里会提到注册中心选型和CAP理论的关系呢，因为我们在落地注册中心之前除了关心前面提到的`应用内`、`应用外`的问题之外，还需要关心注册中心的`高可用`、以及注册中心服务数据的`一致性`的问题。下面先看看CAP理论的内容（[Reference：CAP理论](https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86)）：

* 一致性（Consistency）（等同于所有节点访问同一份最新的数据副本）
* 可用性（Availability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）
* 分区容错性（Partition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。）

通过来说，分布式系统实现高可用的手段无外乎下面两种：

1. 集群部署
2. 多IDL部署

在我们的分布式系统中，我们首先要考虑的就是服务的`高可用`，实现方式如上面提到的两种。在这个过程中我们的服务被划分为了多个节点，正常情况下各个节点是没有问题的，一旦出现了网络故障，各个分区被划分成了网络互不相通的区域，数据就不互通了，这时候为了解决`一致性`问题，解决办法就是把数据复制到其他区域内的节点，这样即使出现了分区，也能访问任意区域内节点上的数据，这就是`分区容错性`。

归纳起来说就是：服务节点越多、分区容错性就越高、一致性也就越难保证。

![cap_theory](../../images/microservice/cap_theory.jpg)

总结起来就是说，对于注册中心的选型，是需要看具体的业务场景的，可以这样简单的理解：

1. Java开发，可以选择Eureka（Eureka提供的sidecar解决方案以支持复杂的业务体系）
2. 云原生、跨语言、复杂体系可以考虑Consul，搭配 Registrator 和 Consul Template 来实现应用外的服务注册与发现