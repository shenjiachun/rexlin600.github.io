---
layout: post
title: "5 Java 并发面试题"
date: 1997-07-01
categories: Java并发
tags: Java并发
excerpt: Java 并发面试题搜集整理
mathjax: true
---

- [1 Java 线程](#1-java-线程)
  - [1.1 简述线程、进程、程序间的关系](#11-简述线程进程程序间的关系)
  - [1.2 线程优缺点](#12-线程优缺点)
  - [1.3 守护线程](#13-守护线程)
  - [1.4 什么时多线程上下文切换](#14-什么时多线程上下文切换)
  - [1.5 Java 中的调度算法时什么](#15-java-中的调度算法时什么)
  - [1.6 什么是线程饥饿](#16-什么是线程饥饿)
  - [1.7 你对线程优先级的理解](#17-你对线程优先级的理解)
  - [1.8 线程的生命周期](#18-线程的生命周期)
  - [1.9 如何结束一个一直运行的线程](#19-如何结束一个一直运行的线程)

### 1 Java 线程

> Java 并发相关问题是一个比较大的栏目，首先需要了解的是 Java 多线程相关的问题

![java并发](../../images/interview/Java并发.png)

> 此外还需要详细了解 wait/notify 机制以明白并发编程中对于线程的等待、通知等问题

![wait/notify机制](../../images/interview/wait:notify机制.png)

> 另外的话，需要知道线程间的通信以及并发编程中的一些问题

![thread_another](../../images/interview/thread_another.png)

![并发编程其他问题](../../images/interview/并发编程其他问题.png)

#### 1.1 简述线程、进程、程序间的关系

- 程序：存储再磁盘或其他存储介质中，包含指令和数据的文件。程序是`静态的代码`
- 进程：是程序的一次执行过程，是系统运行程序的最小基本单位。一个进程执行过程中会经过`创建`、`运行`、`消亡`，它在计算机中一个指令一个指令的运行，同时，每个线程会占用一定的 CPU 时间、内存、文件、输入输出设备的使用权等等。
- 线程：一个进程可以包含多个线程。和进程最大的区别在于进程之间是独立的，而同一个进程中的线程则不一定，可能会相互影响。

#### 1.2 线程优缺点

**优点：**

1. 使用多线程可以将占据时间长的任务放到后台去处理，如媒体文件下载
2. 发挥多核处理器优势

**缺点：**

1. 大量线程降低代码可读性
2. 更多线程需要更多的内存空间
3. 需要注意线程安全问题，提高了编程难度

#### 1.3 守护线程

Java 中有两种线程：`用户线程`以及`守护线程`

- 任何线程都可以设置为守护线程，通过`setDaemon(boolean on)`设置，true 为设置为守护线程，反之为用户线程
- `setDaemon(boolean on)`必须再`start()`方法前调用，否则运行时会抛出 `IllegalThreadStateException` 异常

守护线程，`Daemon`是为其他线程提供服务的，如果全部的用户线程已经执行完成，`Daemon`没有可服务的线程，JVM 关闭。

JVM 的垃圾回收器是一个守护线程，当所有线程以及关闭时，不会再产生垃圾，守护线程就没事情做了，当 JVM 上只剩下 GC（垃圾回收）时，JVM 会自动关闭。

> 程序运行完毕，JVM 会等待`非守护线程`执行完成后关闭，不会等待守护线程

守护线程有一个应用场景，就是当主线程结束时，结束其余的子线程（守护线程）自动关闭，就免去了还要继续关闭子线程的麻烦。不过博主推荐，如果真有这种场景，还是用中断的方式实现比较合理。洗面给出一篇参考文章：

[守护线程](https://blog.csdn.net/u013256816/article/details/50392298)

值得注意的是：`即使你声明的线程是守护线程，放到线程池执行的时候会强制转为用户线程`

#### 1.4 什么时多线程上下文切换

多线程会共同使用一组计算机上的 CPU，而线程数大于给程序分配的 CPU 数量时，为了让各个线程都有执行的机会们就需要轮转使用 CPU。

- 上下文切换是存储和恢复 CPU 状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。

简言之；`不同的线程切换使用CPU发生的切换数据等，就是上下文切换`。

#### 1.5 Java 中的调度算法时什么

线程调度算法有两种模型：`分时调度模型`以及`抢占式调度模型`

- 分时调度模型是指让所有的线程轮流获得 CPU 的使用权,并且平均分配每个线程占用的 CPU 的时间片这个也比较好理解。
- Java 虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用 CPU ，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用 CPU 。处于运行状态的线程会一直运行，直至它不得不放弃 CPU 。（一般不建议使用，防止线程饥饿）

#### 1.6 什么是线程饥饿

线程饥饿：`一个或多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。`

导致线程饥饿的原因：

1. 高优先级线程吞噬所有低优先级线程的 CPU 时间
2. 线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问
3. 线程在等待一个本身也处于永久等待完成的对象(比如调用这个对象的 wait 方法)，因为其他线程总是被持续地获得唤醒。

#### 1.7 你对线程优先级的理解

依赖于线程调度算法，一般是高优先级线程在运行时比低优先级线程拥有优先权。

- 线程优先级是一个 int 变量，1 代表最低优先级，10 代表最高
- 线程优先级最高不一定总是先比低优先级线程执行、
- Java 的线程调度会委托给操作系统处理，所以与具体的操作系统优先级有关（如非特别需要，一般无需设置线程优先级）

#### 1.8 线程的生命周期

线程的生命周期有五个状态，如下：

1. `new`：创建一个 Thread 实例，如：`Thread thread = new Tread();`，这里可能涉及到创建线程的方式，后面会介绍。

2. `runnable`：当线程被创建，其他线程（如：main 线程）调用该对象的 start()方法，该状态的线程位于可运行的线程池中，等待被线程调度选中，获取 CPU 的使用权。

3. `running`：线程获得 CPU 资源正在执行任务，此时除非线程自动放弃 CPU 资源或者有更高的优先级线程进入，否者线程将一直运行到结束。

4. `dead`：当线程执行完毕或被其他线程杀死，线程就进入了死亡状态，这时线程不可能再进入就绪状态等待执行。

5. `blocked`：由于某种原因导致正在运行的线程让出 CPU 并暂停自己的执行，即进入阻塞状态。直到线程进入 running 状态，才有机会再次获得 CPU 资源，赚到 running 状态。

**阻塞的状态有以下状态：**

- 调用`sleep()`方法，可使线程进入睡眠模式
- 调用`wait()`方法
- 被另一个线程所阻塞，调用`suspend()`方法；调用`resume()`方法可以恢复

**下面是线程的生命周期图：**

![thread_life](../../images/interview/thread_life.png)

#### 1.9 如何结束一个一直运行的线程

1. 使用退出标志，可参考下面文章的例子
2. 使用`interrupt`方法，并结合`isInterrupt`方法一起使用：不要使用stop()方法，而是使用Thread提供的interrupt()方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态，退出堵塞代码。

参考文章：[如何安全的结束一个正在运行的线程](https://www.cnblogs.com/baiqiantao/p/5654263.html)



