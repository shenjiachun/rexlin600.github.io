---
layout: post
title: "2. MySQL基础架构"
date: 1997-07-01
categories: MySQL
tags: MySQL
excerpt: MySQL
mathjax: true
---

### MySQL 架构

> 在学习 MySQL 之前有必要了解一下`MySQL`的基础架构是怎样的，这样有利于我们对其数据的操作有一个大致的`猜测`。

---

下面是官方的`MySQL`架构图示：

<img src="/images/mysql/1.png" width="750" height="600" align="center"/>

---

下面是简化后的架构图示：

<img src="/images/mysql/0.png" width="400" height="400" align="center"/>

---

### 简要分析

> 从架构上可以看出`MySQL`的分层体系

1. 数据库连接池
   - 连接限制、权限校验、内存检查、缓存等
2. 插件
   - 语法分析器、优化器、执行器
3. 存储引擎
4. 文件系统

也就是说，`Server`层包含了诸如连接器、分析器、优化器、执行器以及`MySQL`的核心功能、内置函数、存储过程、触发器、视图等都在`Server`层，一般这也是我们关注的重点区域（如果你不涉及研究、修改存储引擎的话）

而存储引擎，从第一张图我们可以看出存储引擎是`插件`机制，自`MySQL 5.5.5`开始，默认的存储引擎是`InnoDB`。当然，我们也可以在创建表的时候指定该表的存储引擎而不是使用默认值，只需要指定`engine=memory`即可。

### 过程梳理之：查询语句的执行过程

#### 一：连接 `MySQL`

> 查看连接空闲状态的命令：`show processlist`，如果长时间连接没有做任何操作，那么将会自动断开，默认是 8 小时。

连接`MySQL`：连接客户端在经过`TCP三次握手`之后成功建立了连接，在这个时候也返回了本次连接所具有的权限。这里值得注意的是：如果你有设计相关权限框架的经验就会很敏锐的发现一个问题：在本次连接断开之前，该连接的权限不会受修改而有影响！！！所以从这里出发就要尽可能避免密码泄露而造成不必要的麻烦。

##### 问题及方案

1. 在`MySQL`中，建立连接往往是一件比较费时费力的事情，所以一般建议使用长连接
2. 使用长连接过多可能出现内存增长过快、程序性能急剧下降，此时有以下建议措施
   1. 定期断开长连接
   2. 执行一次占用内存大的操作后端口长连接再重连
   3. `MySQL 5.7+`版本可以通过`mysql_reset_connections`初始化连接池资源，这个过程不会断开重连、鉴权，只会将连接重置为初始状态

#### 二：查询缓存

一般情况下，建议`不要使用查询缓存`，因为很可能你上个步骤建立的查询缓存在下个更新操作中就直接被清空了，这对于更新压力比较大的数据库来说是一件非常不友好的事情。当然这不意味着我们完全不能使用查询缓存，在这样的场景下可以使用:

- 静态表，例如你的某个配置表，不会经常改动

`MySQL`提供了一个`SQL_CACHE`让我们能够在查询时显式的指定是否使用查询缓存

`mysql> select SQL_CACHE * FROM sys_config;`

额外值得我们注意的是，在`MySQL 8.0`已经将查询缓存这个模块干掉了！

#### 三：分析器

如果没有命中查询缓存的时，`MySQL`就要开始`真正意义上执行 SQL 语句`了。执行 SQL 语句需要先对我们语句进行`词法分析`（查到关键字，分析是属于什么语句），然后再做`语法分析`（即判断你的 SQL 是否合法！）。

一般来说，MySQL 会将语法错误定位到第一个出现语法错误的位置，也就意味着我们要关注的是报错信息的`use near`紧跟着的内容。

> 例如，有时候你写 SQL 查询没注意写了一个不存在的列查询，这个时候报错就发生在分析器阶段。那么有人可能问了，我如何查询一个不存在的列呢？

你可以这样：`select 0 as temp`，来填充一个不存在的列返回。如果嵌套其他数据，这个相当于一个子查询并返回结果，下面给一个简单示例

```
SELECT
	CONCAT(e.first_name, e.last_name) as name,
	temp.salary,
	temp.peroid,
	temp.tmp as tmp
from
	employees e
INNER JOIN (
	SELECT
		s.emp_no as employNo,
		s.salary as salary,
		(select 0) as tmp,
		CONCAT_WS('--', s.from_date, s.to_date) as peroid
	from
		salaries s
	WHERE
		emp_no = '424749') as temp on e.emp_no = temp.employNo
where
	emp_no = '424749'
```

#### 四：优化器

当 MySQL 知道我们要干什么了之后，在执行之前，MySQL 还需要对我们 SQL 语句做一下优化处理以便更快、更好的处理我们想要处理的内容。

这里值得注意的是，我们平时使用的索引等也是在这个过程被`决策`出使用哪个索引。后面会介绍到相关内容。

#### 五：执行器

终于，我们 MySQL 进入了真正意义上的执行阶段（这次是真的执行阶段了，哈哈）。当然，在执行之前还是要查看一下你有没有这个执行权限（我们平时可能用`root`账号习惯了，都没注意还有这样的步骤，所以特别提一下），下面是简略的而执行步骤：

以下面这条语句为例：
`mysql> select * from user where id = '1';`

1. 调用存储引擎的接口获取表的`第一行`数据看是否匹配筛选条件；而针对有索引的数据查询则是调用`查询满足条件的第一行`
2. 调用`下一行`，重复判断逻辑
3. 遍历完成将结果集返回

### 过程梳理之：更新语句的执行过程

#### 一：
